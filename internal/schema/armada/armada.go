// Code generated by tfutils/conv/gen. DO NOT EDIT.
package armada

import (
	"github.com/gamefabric/terraform-provider-gamefabric/internal/resource/core"
	"github.com/gamefabric/terraform-provider-gamefabric/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

type ArmadaModel struct {
	Name        types.String            `tfsdk:"name"`
	Environment types.String            `tfsdk:"environment"`
	Description types.String            `tfsdk:"description"`
	Autoscaling *ArmadaAutoscalingModel `tfsdk:"autoscaling"`
	Region      types.String            `tfsdk:"region"`
	Replicas    []ArmadaReplicaModel    `tfsdk:"replicas"`
	Template    *FleetTemplateSpecModel `tfsdk:"template"`
}

type ArmadaReplicaModel struct {
	RegionType  types.String `tfsdk:"region_type"`
	MinReplicas types.Int32  `tfsdk:"min_replicas"`
	MaxReplicas types.Int32  `tfsdk:"max_replicas"`
	BufferSize  types.Int32  `tfsdk:"buffer_size"`
}

type ArmadaAutoscalingModel struct {
	FixedInterval types.Int32 `tfsdk:"fixed_interval_seconds"`
}

type FleetTemplateSpecModel struct {
	Labels                   map[string]types.String        `tfsdk:"labels"`
	Annotations              map[string]types.String        `tfsdk:"annotations"`
	Containers               []ContainerModel               `tfsdk:"containers"`
	HealthChecks             *HealthModel                   `tfsdk:"health_checks"`
	TerminationConfiguration *TerminationConfigurationModel `tfsdk:"temination_configuration"`
	Strategy                 *DeploymentStrategyModel       `tfsdk:"strategy"`
	Volumes                  []VolumeModel                  `tfsdk:"volumes"`
	GatewayPolicies          []types.String                 `tfsdk:"gateway_policies"`
}

type TerminationConfigurationModel struct {
	GracePeriodSeconds types.Int64 `tfsdk:"grace_period_seconds"`
}

type DeploymentStrategyModel struct {
	RollingUpdate *RollingUpdateDeploymentModel `tfsdk:"rolling_update"`
	Recreate      types.Object                  `tfsdk:"recreate"`
}

type RollingUpdateDeploymentModel struct {
	MaxUnavailable types.String `tfsdk:"max_unavailable"`
	MaxSurge       types.String `tfsdk:"max_surge"`
}

type HealthModel struct {
	Disabled            types.Bool  `tfsdk:"disabled"`
	PeriodSeconds       types.Int32 `tfsdk:"period_seconds"`
	FailureThreshold    types.Int32 `tfsdk:"failure_threshold"`
	InitialDelaySeconds types.Int32 `tfsdk:"initial_delay_seconds"`
}

type ContainerModel struct {
	Name         types.String               `tfsdk:"name"`
	Branch       types.String               `tfsdk:"branch"`
	Image        types.String               `tfsdk:"image"`
	Ports        []PortModel                `tfsdk:"ports"`
	Command      []types.String             `tfsdk:"command"`
	Args         []types.String         `tfsdk:"args"`
	Env          []core.EnvVarV1Model   `tfsdk:"env"`
	ConfigFiles  []ConfigFileMountModel `tfsdk:"config_files"`
	Resources    *ResourceRequirementsModel `tfsdk:"resources"`
	VolumeMounts []VolumeMountModel         `tfsdk:"volume_mounts"`
}

type PortModel struct {
	Name               types.String `tfsdk:"name"`
	Policy             types.String `tfsdk:"policy"`
	ContainerPort      types.Int32  `tfsdk:"container_port"`
	Protocol           types.String `tfsdk:"protocol"`
	ProtectionProtocol types.String `tfsdk:"protection_protocol"`
}

type ConfigFileMountModel struct {
	Name      types.String `tfsdk:"name"`
	MountPath types.String `tfsdk:"mount_path"`
}

type ResourceRequirementsModel struct {
	Limits   map[string]types.String `tfsdk:"limits"`
	Requests map[string]types.String `tfsdk:"requests"`
	Claims   []ResourceClaimModel    `tfsdk:"claims"`
}

type ResourceClaimModel struct {
	Name    types.String `tfsdk:"name"`
	Request types.String `tfsdk:"request"`
}

type VolumeMountModel struct {
	Name              types.String `tfsdk:"name"`
	ReadOnly          types.Bool   `tfsdk:"read_only"`
	RecursiveReadOnly types.String `tfsdk:"recursive_read_only"`
	MountPath         types.String `tfsdk:"mount_path"`
	SubPath           types.String `tfsdk:"sub_path"`
	MountPropagation  types.String `tfsdk:"mount_propagation"`
	SubPathExpr       types.String `tfsdk:"sub_path_expr"`
}

type VolumeModel struct {
	Name     types.String               `tfsdk:"name"`
	EmptyDir *EmptyDirVolumeSourceModel `tfsdk:"empty_dir"`
}

type EmptyDirVolumeSourceModel struct {
	SizeLimit types.String `tfsdk:"size_limit"`
	Medium    types.String `tfsdk:"medium"`
}

func ArmadaAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"name": schema.StringAttribute{
			Description:         "The unique object name within its scope.",
			MarkdownDescription: "The unique object name within its scope.",
			Optional:            true,
			Computed:            true,
			Validators: []validator.String{
				validators.NameValidator{},
			},
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
		},
		"environment": schema.StringAttribute{
			Description:         "The name of the environment the object belongs to.",
			MarkdownDescription: "The name of the environment the object belongs to.",
			Optional:            true,
			Computed:            true,
			Validators: []validator.String{
				validators.EnvironmentValidator{},
			},
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
		},
		"description": schema.StringAttribute{
			Description:         "Description is the optional description of the armada.",
			MarkdownDescription: "Description is the optional description of the armada.",
			Optional:            true,
		},
		"autoscaling": schema.SingleNestedAttribute{
			Description:         "AutoscalingInterval defines the autoscaling strategy.",
			MarkdownDescription: "AutoscalingInterval defines the autoscaling strategy.",
			Optional:            true,
			Attributes:          ArmadaAutoscalingAttributes(),
		},
		"region": schema.StringAttribute{
			Description:         "Region defines the region the game servers are distributed to.",
			MarkdownDescription: "Region defines the region the game servers are distributed to.",
			Required:            true,
		},
		"replicas": schema.ListNestedAttribute{
			Description:         "Replicas specifies the distribution of game servers across the available types of capacity in the selected region.",
			MarkdownDescription: "Replicas specifies the distribution of game servers across the available types of capacity in the selected region.",
			Required:            true,
			NestedObject: schema.NestedAttributeObject{
				Attributes: ArmadaRegionTypeAttributes(),
			},
		},
		"template": schema.SingleNestedAttribute{
			Description:         "Template describes the fleets that are created.",
			MarkdownDescription: "Template describes the fleets that are created.",
			Required:            true,
			Attributes:          FleetTemplateSpecAttributes(),
		},
	}
}

func ArmadaAutoscalingAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"fixed_interval_seconds": schema.Int32Attribute{
			Description:         "Seconds defines how often the auto-scaler will re-evaluate the number of game servers.",
			MarkdownDescription: "Seconds defines how often the auto-scaler will re-evaluate the number of game servers.",
			Optional:            true,
		},
	}
}

func ArmadaRegionTypeAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"region_type": schema.StringAttribute{
			Description:         "RegionType is the name of the region type.",
			MarkdownDescription: "RegionType is the name of the region type.",
			Required:            true,
		},
		"min_replicas": schema.Int32Attribute{
			Description:         "MinReplicas is the minimum number of replicas in the region type.",
			MarkdownDescription: "MinReplicas is the minimum number of replicas in the region type.",
			Required:            true,
		},
		"max_replicas": schema.Int32Attribute{
			Description:         "MaxReplicas is the maximum number of replicas in the region type.",
			MarkdownDescription: "MaxReplicas is the maximum number of replicas in the region type.",
			Required:            true,
		},
		"buffer_size": schema.Int32Attribute{
			Description:         "BufferSize is the number of replicas to have ready all the time.",
			MarkdownDescription: "BufferSize is the number of replicas to have ready all the time.",
			Required:            true,
		},
	}
}

func FleetTemplateSpecAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"labels": schema.MapAttribute{
			Description:         "A map of keys and values that can be used to organize and categorize objects.",
			MarkdownDescription: "A map of keys and values that can be used to organize and categorize objects.",
			Optional:            true,
			ElementType:         types.StringType,
		},
		"annotations": schema.MapAttribute{
			Description:         "An unstructured map of keys and values stored on an object.",
			MarkdownDescription: "An unstructured map of keys and values stored on an object.",
			Optional:            true,
			ElementType:         types.StringType,
		},
		"health_checks": schema.SingleNestedAttribute{
			Description:         "HealthChecks is the health checking configuration for Agones game servers.",
			MarkdownDescription: "HealthChecks is the health checking configuration for Agones game servers.",
			Optional:            true,
			Attributes: map[string]schema.Attribute{
				"disabled": schema.BoolAttribute{
					Optional: true,
				},
				"period_seconds": schema.Int32Attribute{
					Optional: true,
				},
				"failure_threshold": schema.Int32Attribute{
					Optional: true,
				},
				"initial_delay_seconds": schema.Int32Attribute{
					Optional: true,
				},
			},
		},
		"containers": schema.ListNestedAttribute{
			Description:         "Containers is a list of containers belonging to the game server.",
			MarkdownDescription: "Containers is a list of containers belonging to the game server.",
			Required:            true,
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						Description:         "Name is the name of the container.",
						MarkdownDescription: "Name is the name of the container.",
						Required:            true,
					},
					"branch": schema.StringAttribute{
						Description:         "Branch is the name of the image branch.",
						MarkdownDescription: "Branch is the name of the image branch.",
						Required:            true,
					},
					"image": schema.StringAttribute{
						Description:         "Image is a reference to the containerv1.Image to deploy in this container.",
						MarkdownDescription: "Image is a reference to the containerv1.Image to deploy in this container.",
						Required:            true,
					},
					"ports": schema.ListNestedAttribute{
						Description:         "Ports are the ports to expose from the container.",
						MarkdownDescription: "Ports are the ports to expose from the container.",
						Optional:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Description:         "Name is the name of the port.",
									MarkdownDescription: "Name is the name of the port.",
									Required:            true,
								},
								"policy": schema.StringAttribute{
									Description:         "Policy defines the policy for how the HostPort is populated.",
									MarkdownDescription: "Policy defines the policy for how the HostPort is populated.",
									Required:            true,
								},
								"container_port": schema.Int32Attribute{
									Description:         "ContainerPort is the port that is being opened on the specified container&#39;s process.",
									MarkdownDescription: "ContainerPort is the port that is being opened on the specified container&#39;s process.",
									Optional:            true,
								},
								"protocol": schema.StringAttribute{
									Description:         "Protocol is the network protocol being used. Defaults to UDP. TCP is the other option.",
									MarkdownDescription: "Protocol is the network protocol being used. Defaults to UDP. TCP is the other option.",
									Optional:            true,
								},
								"protection_protocol": schema.StringAttribute{
									Description:         "ProtectionProtocol is the optional name of the protection protocol being used.",
									MarkdownDescription: "ProtectionProtocol is the optional name of the protection protocol being used.",
									Optional:            true,
								},
							},
						},
					},
					"command": schema.ListAttribute{
						Description:         "Command is the entrypoint array. This is not executed within a shell.",
						MarkdownDescription: "Command is the entrypoint array. This is not executed within a shell.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"args": schema.ListAttribute{
						Description:         "Args are arguments to the entrypoint.",
						MarkdownDescription: "Args are arguments to the entrypoint.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"env": schema.ListNestedAttribute{
						Description:         "Env is a list of environment variables to set in the container.",
						MarkdownDescription: "Env is a list of environment variables to set in the container.",
						Optional:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: EnvVarAttributes(),
						},
					},
					"config_files": schema.ListNestedAttribute{
						Description:         "ConfigFiles is a list of configuration files to mount into the containers filesystem.",
						MarkdownDescription: "ConfigFiles is a list of configuration files to mount into the containers filesystem.",
						Optional:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Description:         "Name is the name of the configuration file.",
									MarkdownDescription: "Name is the name of the configuration file.",
									Required:            true,
								},
								"mount_path": schema.StringAttribute{
									Description:         "MountPath is the path to mount the configuration file on.",
									MarkdownDescription: "MountPath is the path to mount the configuration file on.",
									Required:            true,
								},
							},
						},
					},
					"resources": schema.SingleNestedAttribute{
						Description:         "Resources are the compute resources required by the container.",
						MarkdownDescription: "Resources are the compute resources required by the container.",
						Optional:            true,
						Attributes: map[string]schema.Attribute{
							"limits": schema.MapAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Validators: []validator.Map{
									mapvalidator.ValueStringsAre(quantityValidator{}),
								},
							},
							"requests": schema.MapAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Validators: []validator.Map{
									mapvalidator.ValueStringsAre(quantityValidator{}),
								},
							},
							"claims": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Optional: true,
										},
										"request": schema.StringAttribute{
											Optional: true,
										},
									},
								},
							},
						},
					},
					"volume_mounts": schema.ListNestedAttribute{
						Description:         "VolumeMounts are the volumes to mount into the container&#39;s filesystem.",
						MarkdownDescription: "VolumeMounts are the volumes to mount into the container&#39;s filesystem.",
						Optional:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional: true,
								},
								"read_only": schema.BoolAttribute{
									Optional: true,
								},
								"recursive_read_only": schema.StringAttribute{
									Optional: true,
								},
								"mount_path": schema.StringAttribute{
									Optional: true,
								},
								"sub_path": schema.StringAttribute{
									Optional: true,
								},
								"mount_propagation": schema.StringAttribute{
									Optional: true,
								},
								"sub_path_expr": schema.StringAttribute{
									Optional: true,
								},
							},
						},
					},
				},
			},
		},
		"temination_configuration": schema.SingleNestedAttribute{
			Description:         "TerminationConfiguration configures the shutdown behaviour of game servers.",
			MarkdownDescription: "TerminationConfiguration configures the shutdown behaviour of game servers.",
			Optional:            true,
			Attributes: map[string]schema.Attribute{
				"grace_period_seconds": schema.Int64Attribute{
					Description:         "GracePeriodSeconds is the optional duration in seconds the game servers need to terminate gracefully. Defaults to 30 seconds.",
					MarkdownDescription: "GracePeriodSeconds is the optional duration in seconds the game servers need to terminate gracefully. Defaults to 30 seconds.",
					Optional:            true,
				},
			},
		},
		"strategy": schema.SingleNestedAttribute{
			Description:         "Strategy is the deployment strategy.",
			MarkdownDescription: "Strategy is the deployment strategy.",
			Optional:            true,
			Attributes: map[string]schema.Attribute{
				"rolling_update": schema.SingleNestedAttribute{
					Optional: true,
					Attributes: map[string]schema.Attribute{
						"max_unavailable": schema.StringAttribute{
							Optional: true,
						},
						"max_surge": schema.StringAttribute{
							Optional: true,
						},
					},
					Validators: []validator.Object{
						objectvalidator.ExactlyOneOf(path.MatchRelative().AtParent().AtName("recreate")),
					},
				},
				"recreate": schema.SingleNestedAttribute{
					Optional: true,
					Validators: []validator.Object{
						objectvalidator.ExactlyOneOf(path.MatchRelative().AtParent().AtName("rolling_update")),
					},
				},
			},
		},
		"volumes": schema.ListNestedAttribute{
			Description:         "Volumes are pod volumes.",
			MarkdownDescription: "Volumes are pod volumes.",
			Optional:            true,
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						Description:         "Name is the name of the volume mount.",
						MarkdownDescription: "Name is the name of the volume mount.",
						Required:            true,
					},
					"empty_dir": schema.SingleNestedAttribute{
						Description:         "EmptyDir configures an empty dir volume.",
						MarkdownDescription: "EmptyDir configures an empty dir volume.",
						Optional:            true,
						Attributes: map[string]schema.Attribute{
							"size_limit": schema.StringAttribute{
								Description:         "SizeLimit is the maximum size of the volume.",
								MarkdownDescription: "SizeLimit is the maximum size of the volume.",
								Optional:            true,
							},
							"medium": schema.StringAttribute{
								Description:         "Medium is the storage medium type.",
								MarkdownDescription: "Medium is the storage medium type.",
								Optional:            true,
							},
						},
					},
				},
			},
		},
		"gateway_policies": schema.ListAttribute{
			Description:         "GatewayPolicies are the gateway policy names applied to the game servers.",
			MarkdownDescription: "GatewayPolicies are the gateway policy names applied to the game servers.",
			Optional:            true,
			ElementType:         types.StringType,
		},
	}
}

func EnvVarAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"name": schema.StringAttribute{
			Description:         "Name is the name of the environment variable.",
			MarkdownDescription: "Name is the name of the environment variable.",
			Required:            true,
		},
		"value": schema.StringAttribute{
			Description:         "Value is the value of the environment variable.",
			MarkdownDescription: "Value is the value of the environment variable.",
			Optional:            true,
		},
		"value_from": schema.SingleNestedAttribute{
			Description:         "ValueFrom is the source for the environment variable&#39;s value.",
			MarkdownDescription: "ValueFrom is the source for the environment variable&#39;s value.",
			Optional:            true,
			Attributes: map[string]schema.Attribute{
				"field_ref": schema.SingleNestedAttribute{
					Description:         "FieldRef selects the field of the pod. Supports metadata.name, metadata.namespace, `metadata.labels[&#39;&lt;KEY&gt;&#39;]`, `metadata.annotations[&#39;&lt;KEY&gt;&#39;]`, metadata.armadaName, metadata.regionName, metadata.regionTypeName, metadata.siteName, metadata.imageBranch, metadata.imageName, metadata.imageTag, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.",
					MarkdownDescription: "FieldRef selects the field of the pod. Supports metadata.name, metadata.namespace, `metadata.labels[&#39;&lt;KEY&gt;&#39;]`, `metadata.annotations[&#39;&lt;KEY&gt;&#39;]`, metadata.armadaName, metadata.regionName, metadata.regionTypeName, metadata.siteName, metadata.imageBranch, metadata.imageName, metadata.imageTag, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.",
					Optional:            true,
					Attributes: map[string]schema.Attribute{
						"api_version": schema.StringAttribute{
							Optional: true,
						},
						"field_path": schema.StringAttribute{
							Optional: true,
						},
					},
				},
				"config_file_key_ref": schema.SingleNestedAttribute{
					Description:         "ConfigFileKeyRef select the configuration file.",
					MarkdownDescription: "ConfigFileKeyRef select the configuration file.",
					Optional:            true,
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Description:         "Name is the name of the configuration file.",
							MarkdownDescription: "Name is the name of the configuration file.",
							Required:            true,
						},
					},
				},
			},
		},
	}
}
