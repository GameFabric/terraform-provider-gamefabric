// Code generated by tfutils/conv/gen. DO NOT EDIT.
package formation

import (
	core2 "github.com/gamefabric/terraform-provider-gamefabric/internal/resource/core"
	"github.com/gamefabric/terraform-provider-gamefabric/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

type VesselModel struct {
	Name        types.String     `tfsdk:"name"`
	Environment types.String     `tfsdk:"environment"`
	Spec        *VesselSpecModel `tfsdk:"spec"`
}

type VesselSpecModel struct {
	Description             types.String                        `tfsdk:"description"`
	Suspend                 types.Bool                          `tfsdk:"suspend"`
	Region                  types.String                        `tfsdk:"region"`
	Template                *GameServerTemplateSpecModel        `tfsdk:"template"`
	TerminationGracePeriods *VesselTerminationGracePeriodsModel `tfsdk:"termination_grace_periods"`
}

type VesselTerminationGracePeriodsModel struct {
	Maintenance   types.Int64 `tfsdk:"maintenance"`
	SpecChange    types.Int64 `tfsdk:"spec_change"`
	UserInitiated types.Int64 `tfsdk:"user_initiated"`
}

type GameServerTemplateSpecModel struct {
	Labels      map[string]types.String `tfsdk:"labels"`
	Annotations map[string]types.String `tfsdk:"annotations"`
	Spec        *GameServerSpecModel    `tfsdk:"spec"`
}

type GameServerSpecModel struct {
	GatewayPolicies               types.List       `tfsdk:"gateway_policies"`
	Health                        *HealthModel     `tfsdk:"health"`
	Containers                    []ContainerModel `tfsdk:"containers"`
	TerminationGracePeriodSeconds types.Int64      `tfsdk:"termination_grace_period_seconds"`
	Volumes                       []VolumeModel    `tfsdk:"volumes"`
}

type HealthModel struct {
	Disabled            types.Bool  `tfsdk:"disabled"`
	PeriodSeconds       types.Int32 `tfsdk:"period_seconds"`
	FailureThreshold    types.Int32 `tfsdk:"failure_threshold"`
	InitialDelaySeconds types.Int32 `tfsdk:"initial_delay_seconds"`
}

type ContainerModel struct {
	Name            types.String               `tfsdk:"name"`
	Branch          types.String               `tfsdk:"branch"`
	Image           types.String               `tfsdk:"image"`
	Ports           []PortModel                `tfsdk:"ports"`
	Command         types.List                 `tfsdk:"command"`
	Args            types.List                 `tfsdk:"args"`
	Env             []core2.EnvVarModel        `tfsdk:"env"`
	ConfigFiles     []ConfigFileMountModel     `tfsdk:"config_files"`
	Resources       *ResourceRequirementsModel `tfsdk:"resources"`
	SecurityContext *SecurityContextModel      `tfsdk:"security_context"`
	VolumeMounts    []VolumeMountModel         `tfsdk:"volume_mounts"`
}

type PortModel struct {
	Name               types.String `tfsdk:"name"`
	Policy             types.String `tfsdk:"policy"`
	ContainerPort      types.Int32  `tfsdk:"container_port"`
	Protocol           types.String `tfsdk:"protocol"`
	ProtectionProtocol types.String `tfsdk:"protection_protocol"`
}

type ConfigFileMountModel struct {
	Name      types.String `tfsdk:"name"`
	MountPath types.String `tfsdk:"mount_path"`
}

type ResourceRequirementsModel struct {
	Limits   types.Map            `tfsdk:"limits"`
	Requests types.Map            `tfsdk:"requests"`
	Claims   []ResourceClaimModel `tfsdk:"claims"`
}

type ResourceClaimModel struct {
	Name    types.String `tfsdk:"name"`
	Request types.String `tfsdk:"request"`
}

type SecurityContextModel struct {
	Capabilities             *CapabilitiesModel                  `tfsdk:"capabilities"`
	Privileged               types.Bool                          `tfsdk:"privileged"`
	SELinuxOptions           *SeLinuxOptionsModel                `tfsdk:"se_linux_options"`
	WindowsOptions           *WindowsSecurityContextOptionsModel `tfsdk:"windows_options"`
	RunAsUser                types.Int64                         `tfsdk:"run_as_user"`
	RunAsGroup               types.Int64                         `tfsdk:"run_as_group"`
	RunAsNonRoot             types.Bool                          `tfsdk:"run_as_non_root"`
	ReadOnlyRootFilesystem   types.Bool                          `tfsdk:"read_only_root_filesystem"`
	AllowPrivilegeEscalation types.Bool                          `tfsdk:"allow_privilege_escalation"`
	ProcMount                types.String                        `tfsdk:"proc_mount"`
	SeccompProfile           *SeccompProfileModel                `tfsdk:"seccomp_profile"`
	AppArmorProfile          *AppArmorProfileModel               `tfsdk:"app_armor_profile"`
}

type CapabilitiesModel struct {
	Add  types.List `tfsdk:"add"`
	Drop types.List `tfsdk:"drop"`
}

type SeLinuxOptionsModel struct {
	User  types.String `tfsdk:"user"`
	Role  types.String `tfsdk:"role"`
	Type  types.String `tfsdk:"type"`
	Level types.String `tfsdk:"level"`
}

type WindowsSecurityContextOptionsModel struct {
	GMSACredentialSpecName types.String `tfsdk:"gmsa_credential_spec_name"`
	GMSACredentialSpec     types.String `tfsdk:"gmsa_credential_spec"`
	RunAsUserName          types.String `tfsdk:"run_as_user_name"`
	HostProcess            types.Bool   `tfsdk:"host_process"`
}

type SeccompProfileModel struct {
	Type             types.String `tfsdk:"type"`
	LocalhostProfile types.String `tfsdk:"localhost_profile"`
}

type AppArmorProfileModel struct {
	Type             types.String `tfsdk:"type"`
	LocalhostProfile types.String `tfsdk:"localhost_profile"`
}

type VolumeMountModel struct {
	Name              types.String `tfsdk:"name"`
	ReadOnly          types.Bool   `tfsdk:"read_only"`
	RecursiveReadOnly types.String `tfsdk:"recursive_read_only"`
	MountPath         types.String `tfsdk:"mount_path"`
	SubPath           types.String `tfsdk:"sub_path"`
	MountPropagation  types.String `tfsdk:"mount_propagation"`
	SubPathExpr       types.String `tfsdk:"sub_path_expr"`
}

type VolumeModel struct {
	Name       types.String                 `tfsdk:"name"`
	Type       types.String                 `tfsdk:"type"`
	EmptyDir   *EmptyDirVolumeSourceModel   `tfsdk:"empty_dir"`
	Persistent *PersistentVolumeSourceModel `tfsdk:"persistent"`
}

type EmptyDirVolumeSourceModel struct {
	SizeLimit types.String `tfsdk:"size_limit"`
	Medium    types.String `tfsdk:"medium"`
}

type PersistentVolumeSourceModel struct {
	VolumeName types.String `tfsdk:"volume_name"`
}

func VesselAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"name": schema.StringAttribute{
			Description:         "The unique object name within its scope.",
			MarkdownDescription: "The unique object name within its scope.",
			Optional:            true,
			Computed:            true,
			Validators: []validator.String{
				validators.NameValidator{},
			},
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
		},
		"environment": schema.StringAttribute{
			Description:         "The name of the environment the object belongs to.",
			MarkdownDescription: "The name of the environment the object belongs to.",
			Optional:            true,
			Computed:            true,
			Validators: []validator.String{
				validators.EnvironmentValidator{},
			},
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.RequiresReplace(),
			},
		},
		"spec": schema.SingleNestedAttribute{
			Description:         "Spec defines the desired vessel.",
			MarkdownDescription: "Spec defines the desired vessel.",
			Optional:            true,
			Attributes: map[string]schema.Attribute{
				"description": schema.StringAttribute{
					Description:         "Description is the optional description of the vessel.",
					MarkdownDescription: "Description is the optional description of the vessel.",
					Optional:            true,
				},
				"suspend": schema.BoolAttribute{
					Description:         "Suspend specifies whether the vessel should create a game server or not.",
					MarkdownDescription: "Suspend specifies whether the vessel should create a game server or not.",
					Optional:            true,
				},
				"region": schema.StringAttribute{
					Description:         "Region defines the region the vessel is deployed to.",
					MarkdownDescription: "Region defines the region the vessel is deployed to.",
					Required:            true,
				},
				"template": schema.SingleNestedAttribute{
					Description:         "Template describes the game server that is created.",
					MarkdownDescription: "Template describes the game server that is created.",
					Required:            true,
					Attributes:          GameServerTemplateSpecAttributes(),
				},
				"termination_grace_periods": schema.SingleNestedAttribute{
					Description:         "TerminationGracePeriods are the optional durations that a game server has to terminate gracefully. If this value is nil, the default grace period for each situation will be used. These durations only apply when a game server is in use.",
					MarkdownDescription: "TerminationGracePeriods are the optional durations that a game server has to terminate gracefully. If this value is nil, the default grace period for each situation will be used. These durations only apply when a game server is in use.",
					Optional:            true,
					Attributes:          VesselTerminationGracePeriodsAttributes(),
				},
			},
		},
	}
}

func VesselTerminationGracePeriodsAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"maintenance": schema.Int64Attribute{
			Description:         "Maintenance is the optional duration in seconds that a game server has to gracefully terminate when the site it is running is cordoned.",
			MarkdownDescription: "Maintenance is the optional duration in seconds that a game server has to gracefully terminate when the site it is running is cordoned.",
			Optional:            true,
		},
		"spec_change": schema.Int64Attribute{
			Description:         "SpecChange is the optional duration in seconds that a game server has to gracefully terminate when a spec change is detected.",
			MarkdownDescription: "SpecChange is the optional duration in seconds that a game server has to gracefully terminate when a spec change is detected.",
			Optional:            true,
		},
		"user_initiated": schema.Int64Attribute{
			Description:         "UserInitiated is the optional duration in seconds that a game server has to gracefully terminate when user initiates a restart or suspends a vessel.",
			MarkdownDescription: "UserInitiated is the optional duration in seconds that a game server has to gracefully terminate when user initiates a restart or suspends a vessel.",
			Optional:            true,
		},
	}
}

func GameServerTemplateSpecAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"metadata": schema.SingleNestedAttribute{
			Description:         "Standard object&#39;s metadata.",
			MarkdownDescription: "Standard object&#39;s metadata.",
			Optional:            true,
			Attributes: map[string]schema.Attribute{
				"labels": schema.MapAttribute{
					Description:         "A map of keys and values that can be used to organize and categorize objects.",
					MarkdownDescription: "A map of keys and values that can be used to organize and categorize objects.",
					Optional:            true,
					ElementType:         types.StringType,
				},
				"annotations": schema.MapAttribute{
					Description:         "An unstructured map of keys and values stored on an object.",
					MarkdownDescription: "An unstructured map of keys and values stored on an object.",
					Optional:            true,
					ElementType:         types.StringType,
				},
			},
		},
		"spec": schema.SingleNestedAttribute{
			Description:         "Spec defines the desired game server.",
			MarkdownDescription: "Spec defines the desired game server.",
			Optional:            true,
			Attributes: map[string]schema.Attribute{
				"gateway_policies": schema.ListAttribute{
					Description:         "GatewayPolicies are the gateway policy names applied to the game servers.",
					MarkdownDescription: "GatewayPolicies are the gateway policy names applied to the game servers.",
					Optional:            true,
					ElementType:         types.StringType,
				},
				"health": schema.SingleNestedAttribute{
					Description:         "Health is the health checking configuration for Agones game servers.",
					MarkdownDescription: "Health is the health checking configuration for Agones game servers.",
					Optional:            true,
					Attributes: map[string]schema.Attribute{
						"disabled": schema.BoolAttribute{
							Optional: true,
						},
						"period_seconds": schema.Int32Attribute{
							Optional: true,
						},
						"failure_threshold": schema.Int32Attribute{
							Optional: true,
						},
						"initial_delay_seconds": schema.Int32Attribute{
							Optional: true,
						},
					},
				},
				"containers": schema.ListNestedAttribute{
					Description:         "Containers is a list of container belonging to the game server.",
					MarkdownDescription: "Containers is a list of container belonging to the game server.",
					Required:            true,
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								Description:         "Name is the name of the container.",
								MarkdownDescription: "Name is the name of the container.",
								Required:            true,
							},
							"branch": schema.StringAttribute{
								Description:         "Branch is the name of the image branch.",
								MarkdownDescription: "Branch is the name of the image branch.",
								Required:            true,
							},
							"image": schema.StringAttribute{
								Description:         "Image is a reference to the containerv1.Image to deploy in this container.",
								MarkdownDescription: "Image is a reference to the containerv1.Image to deploy in this container.",
								Required:            true,
							},
							"ports": schema.ListNestedAttribute{
								Description:         "Ports are the ports to expose from the container.",
								MarkdownDescription: "Ports are the ports to expose from the container.",
								Optional:            true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Description:         "Name is the name of the port.",
											MarkdownDescription: "Name is the name of the port.",
											Required:            true,
										},
										"policy": schema.StringAttribute{
											Description:         "Policy defines the policy for how the HostPort is populated.",
											MarkdownDescription: "Policy defines the policy for how the HostPort is populated.",
											Required:            true,
										},
										"container_port": schema.Int32Attribute{
											Description:         "ContainerPort is the port that is being opened on the specified container&#39;s process.",
											MarkdownDescription: "ContainerPort is the port that is being opened on the specified container&#39;s process.",
											Optional:            true,
										},
										"protocol": schema.StringAttribute{
											Description:         "Protocol is the network protocol being used. Defaults to UDP. TCP and TCPUDP are other options.",
											MarkdownDescription: "Protocol is the network protocol being used. Defaults to UDP. TCP and TCPUDP are other options.",
											Optional:            true,
										},
										"protection_protocol": schema.StringAttribute{
											Description:         "ProtectionProtocol is the optional name of the protection protocol being used.",
											MarkdownDescription: "ProtectionProtocol is the optional name of the protection protocol being used.",
											Optional:            true,
										},
									},
								},
							},
							"command": schema.ListAttribute{
								Description:         "Command is the entrypoint array. This is not executed within a shell.",
								MarkdownDescription: "Command is the entrypoint array. This is not executed within a shell.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"args": schema.ListAttribute{
								Description:         "Args are arguments to the entrypoint.",
								MarkdownDescription: "Args are arguments to the entrypoint.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"env": schema.ListNestedAttribute{
								Description:         "Env is a list of environment variables to set in the container.",
								MarkdownDescription: "Env is a list of environment variables to set in the container.",
								Optional:            true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: core2.EnvVarAttributes(),
								},
							},
							"config_files": schema.ListNestedAttribute{
								Description:         "ConfigFiles is a list of configuration files to mount into the containers filesystem.",
								MarkdownDescription: "ConfigFiles is a list of configuration files to mount into the containers filesystem.",
								Optional:            true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Description:         "Name is the name of the configuration file.",
											MarkdownDescription: "Name is the name of the configuration file.",
											Required:            true,
										},
										"mount_path": schema.StringAttribute{
											Description:         "MountPath is the path to mount the configuration file on.",
											MarkdownDescription: "MountPath is the path to mount the configuration file on.",
											Required:            true,
										},
									},
								},
							},
							"resources": schema.SingleNestedAttribute{
								Description:         "Resources are the compute resources required by the container.",
								MarkdownDescription: "Resources are the compute resources required by the container.",
								Optional:            true,
								Attributes: map[string]schema.Attribute{
									"limits": schema.MapAttribute{
										Optional:    true,
										ElementType: types.StringType,
									},
									"requests": schema.MapAttribute{
										Optional:    true,
										ElementType: types.StringType,
									},
									"claims": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Optional: true,
												},
												"request": schema.StringAttribute{
													Optional: true,
												},
											},
										},
									},
								},
							},
							"security_context": schema.SingleNestedAttribute{
								Description:         "SecurityContext defines the security options the container should be run with.",
								MarkdownDescription: "SecurityContext defines the security options the container should be run with.",
								Optional:            true,
								Attributes: map[string]schema.Attribute{
									"capabilities": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"add": schema.ListAttribute{
												Optional:    true,
												ElementType: types.StringType,
											},
											"drop": schema.ListAttribute{
												Optional:    true,
												ElementType: types.StringType,
											},
										},
									},
									"privileged": schema.BoolAttribute{
										Optional: true,
									},
									"se_linux_options": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"user": schema.StringAttribute{
												Optional: true,
											},
											"role": schema.StringAttribute{
												Optional: true,
											},
											"type": schema.StringAttribute{
												Optional: true,
											},
											"level": schema.StringAttribute{
												Optional: true,
											},
										},
									},
									"windows_options": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"gmsa_credential_spec_name": schema.StringAttribute{
												Optional: true,
											},
											"gmsa_credential_spec": schema.StringAttribute{
												Optional: true,
											},
											"run_as_user_name": schema.StringAttribute{
												Optional: true,
											},
											"host_process": schema.BoolAttribute{
												Optional: true,
											},
										},
									},
									"run_as_user": schema.Int64Attribute{
										Optional: true,
									},
									"run_as_group": schema.Int64Attribute{
										Optional: true,
									},
									"run_as_non_root": schema.BoolAttribute{
										Optional: true,
									},
									"read_only_root_filesystem": schema.BoolAttribute{
										Optional: true,
									},
									"allow_privilege_escalation": schema.BoolAttribute{
										Optional: true,
									},
									"proc_mount": schema.StringAttribute{
										Optional: true,
									},
									"seccomp_profile": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional: true,
											},
											"localhost_profile": schema.StringAttribute{
												Optional: true,
											},
										},
									},
									"app_armor_profile": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional: true,
											},
											"localhost_profile": schema.StringAttribute{
												Optional: true,
											},
										},
									},
								},
							},
							"volume_mounts": schema.ListNestedAttribute{
								Description:         "VolumeMounts are the volumes to mount into the container&#39;s filesystem.",
								MarkdownDescription: "VolumeMounts are the volumes to mount into the container&#39;s filesystem.",
								Optional:            true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Optional: true,
										},
										"read_only": schema.BoolAttribute{
											Optional: true,
										},
										"recursive_read_only": schema.StringAttribute{
											Optional: true,
										},
										"mount_path": schema.StringAttribute{
											Optional: true,
										},
										"sub_path": schema.StringAttribute{
											Optional: true,
										},
										"mount_propagation": schema.StringAttribute{
											Optional: true,
										},
										"sub_path_expr": schema.StringAttribute{
											Optional: true,
										},
									},
								},
							},
						},
					},
				},
				"termination_grace_period_seconds": schema.Int64Attribute{
					Description:         "TerminationGracePeriodSeconds is the optional duration in seconds the game servers need to terminate gracefully. Defaults to 30 seconds.",
					MarkdownDescription: "TerminationGracePeriodSeconds is the optional duration in seconds the game servers need to terminate gracefully. Defaults to 30 seconds.",
					Optional:            true,
				},
				"volumes": schema.ListNestedAttribute{
					Description:         "Volumes are pod volumes.",
					MarkdownDescription: "Volumes are pod volumes.",
					Optional:            true,
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								Description:         "Name is the name of the volume mount.",
								MarkdownDescription: "Name is the name of the volume mount.",
								Required:            true,
							},
							"type": schema.StringAttribute{
								Description:         "Type is the volume type.",
								MarkdownDescription: "Type is the volume type.",
								Optional:            true,
							},
							"empty_dir": schema.SingleNestedAttribute{
								Description:         "EmptyDir configures an empty dir volume.",
								MarkdownDescription: "EmptyDir configures an empty dir volume.",
								Optional:            true,
								Attributes: map[string]schema.Attribute{
									"size_limit": schema.StringAttribute{
										Description:         "SizeLimit is the maximum size of the volume.",
										MarkdownDescription: "SizeLimit is the maximum size of the volume.",
										Optional:            true,
									},
									"medium": schema.StringAttribute{
										Description:         "Medium is the storage medium type.",
										MarkdownDescription: "Medium is the storage medium type.",
										Optional:            true,
									},
								},
							},
							"persistent": schema.SingleNestedAttribute{
								Description:         "Persistent configures a persistent volume.",
								MarkdownDescription: "Persistent configures a persistent volume.",
								Optional:            true,
								Attributes: map[string]schema.Attribute{
									"volume_name": schema.StringAttribute{
										Description:         "VolumeName is the name of the volume to store data in.",
										MarkdownDescription: "VolumeName is the name of the volume to store data in.",
										Required:            true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}
